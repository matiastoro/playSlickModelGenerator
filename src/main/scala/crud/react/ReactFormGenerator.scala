
package via56.slickGenerator.crud.react

import via56.slickGenerator._
import via56.slickGenerator.Table

case class ReactFormGenerator(table: Table, tablesOneToMany: List[Table] = List(), submodulePackageString: String, tables: List[Table] = List()) extends CodeGenerator{

  def attachments = table.columns.filter{ case c: Column => c.tpe=="Attachment"; case _ => false}

  def generateInputs(columns: List[AbstractColumn], prefix: String = "")(implicit inline: Boolean = false): String = {
    //println("GENERATING REACT FORM ", table)
    //println("AA",tablesOneToMany)
    val groupTab = (" "*10)
    val tab = (" "*12)

    columns.map{ col => col match{
      case c: Column if !c.synthetic && c.display != DisplayType.Hidden =>
        val input = if(c.isId) /* The ID is going to be autogenerated */
          tab+c.formHelperReact(prefix, hidden = true)
        else
          tab+c.formHelperReact(prefix)
        groupTab+"<div>\n"+input+"\n"+groupTab+"</div>"
      case s: SubClass => generateInputs(s.cols, s.name+".")//throw new Exception("Subclas")//generateInputs(s.cols, s.name+".")
      case o: OneToMany => o.formHelper(submodulePackageString, Some(table))
      case _ => ""
    }}.mkString("\n")
  }
  def generateOneToMany(inputs: String): String ={
    s"""
export class ${table.className}FormInline extends GFormInline{
    apiOptionsUrl = "/${table.tableName}/options"
    renderForm(){
        const obj = this.props.obj;
        const readOnly = this.props.readOnly
        const errors = this.props.errors
        const hide = this.props.hide || []
        const i = this.props.i
        const prefix = this.props.prefix+(this.props.single?".":"["+i+"].")
        const options = this.state.options
        return <div>
${inputs}
        </div>
    }

}
    """
  }

  def getFkInlinesImports(columns: List[AbstractColumn]): List[String] = {
    val groupTab = (" "*10)
    val tab = (" "*12)

    columns.flatMap{ col => col match{
      case c: Column if c.foreignKey.isDefined && c.foreignKey.get.inline =>
        List(s"""import {${c.foreignKey.get.className}FormInline} from '../${c.foreignKey.get.tableName}/${c.foreignKey.get.className}Form'""")
      case s: SubClass => getFkInlinesImports(s.cols)
      case _ => List()
    }}
  }



  def generate: String = {


    val oneToManiesImps = table.oneToManies.map{c => {
      s"""import {${c.className}FormInline} from '../${c.name}/${c.className}Form'"""
    }}.mkString("\n")
    val oneToManiesImports = if(table.oneToManies.length>0){
      s"""import {GNestedForms} from '../gforms/GForm';
        |${oneToManiesImps}
      """.stripMargin
    } else {
      ""
    }

    val fkInlinesImports = getFkInlinesImports(table.columns).mkString("\n")

    //val inline = tablesOneToMany.length>0 || tables.exists(t => t.columns.exists(c => ))
    val inline = true

    val imports = s"""import React from 'react';
import TextField from '../gforms/GTextField';
import SelectField from '../gforms/GAutocomplete';
import Checkbox from '../gforms/GCheckbox';
import DateTime from '../gforms/GDateTime';
import DatePicker from '../gforms/GDatePicker';
import HiddenField from '../gforms/GHiddenField';
import GForm from '../gforms/GForm';
${if(attachments.length>0) "import FileUpload from '../gforms/FileUpload'" else ""}
${if(inline) "import {GFormInline} from '../gforms/GForm';" else ""}
${oneToManiesImports}
${fkInlinesImports}
//inputs de nested
"""
    val inputs = generateInputs(table.columns)
    val inputsInline = generateInputs(table.columns)(true)


    val oneToMany = if(inline) generateOneToMany(inputsInline) else ""
    val withOptions = table.foreignColumns.length>0
    val result =
      s"""$imports


export default class ${table.className}Form extends GForm{
    showUrl =  '/${table.tableName}/'
    listUrl =  '/${table.tableName}/'
    apiGetUrl =  '/${table.tableName}/show/'
    apiCreateUrl = '/${table.tableName}/save'
    apiUpdateUrl = '/${table.tableName}/update/'
    apiDeleteUrl = '/${table.tableName}/delete/'
    ${if(withOptions) s"""apiOptionsUrl = "/${table.tableName}/options"""" else ""}

    objStr = '${table.label}'
    objGender = 'F'

    renderForm(obj, errors){
        const readOnly = this.state.readOnly
        ${if(withOptions) "const hide = this.props.hide || []" else ""}
        const options = this.state.options
        const prefix = ""
        return <div>
${inputs}
        </div>
    }

}

${oneToMany}
      """
    result

  }
}
